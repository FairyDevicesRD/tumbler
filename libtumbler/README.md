# libtumbler
Hardware contol library for Fairy I/O Tumbler

## 概要

libtumbler は、Tumbler の各サブシステムを制御するためのライブラリです。下記のサブシステムが制御対象となります。

### 機能

- LED リング
- タッチボタン
- 簡易スピーカー制御（通常のスピーカー制御には portaudio 等の一般的なライブラリをご利用ください）

## 構築

### 依存ライブラリ

#### 必須

- Wiring Pi（wiringpi）
- ALSA library（libasound2-dev）

### ビルド

``````````{.cpp}
$ autoreconf -vif
$ ./configure
$ make
$ make check 
$ make install
``````````

- `make check` はビルド自体には不要です。`make check` では LED リングが点灯したり、音声が再生されたりする場合がありますのでご注意ください。
- `make chcek` が動作しない場合、Arduino スケッチが古い可能性があります。本レポジトリの `arduino/` 以下から最新スケッチをインストールしてください。
- Tumbler 上でのビルド及び動作のみ確認されています。

## libtumbler API

### API の概要

各サブシステムは、ライブラリ上はシングルトン・インスタンスとして取得することができます。シングルトン・インスタンスに対するメンバー関数呼び出しにより、各サブシステムをコントロールします。

### LED リング制御

#### LED クラス

LED クラスは、ひとつのフルカラー LED を表すクラスです。ひとつのフルカラー LED は、赤・緑・青、それぞれ 256 段階の値を取ることができます。コンストラクタで RGB を指定してインスタンス化することができます。

サンプルプログラムは `/examples` 以下にあります。


##### LED クラスのコンストラクタ

``````````.cpp
LED::LED();
LED::LED(int r,int g,int b);
``````````

コンストラクタでは、R,G,B をそれぞれ [0,255] で指定することができます。指定しなかった場合は、全てゼロ、すなわち消灯状態となります。

#### Frame クラス

Frame クラスは、LED リングの全体、すなわち 18 個の色指定された LED インスタンスを持つクラスです。フレームの名称は、アニメーションする場合のキーフレームとなることに由来しています。

##### Frame クラスのコンストラクタ

``````````.cpp
Frame::Frame();
Frame::Frame(const LED& background);
``````````

デフォルトコンストラクタを利用した場合、18 個すべての LED は消灯状態となります。オーバーロードされたもうひとつのコンストラクタでは、ひとつの LED インスタンスを取ることができ、18 個すべての LED は指定された LED の色指定となります。

##### setLED()

``````````.cpp
void Frame::setLED(int index, const LED& led);
``````````

第一引数で指定した位置に、第二引数で指定した LED をセットします。`index` は LED 番号であり、[0,17] の値を取ります。

#### LEDRing クラス

LEDRing クラスは、Tumbler の LED リングを表すクラスです。シングルトン・インスタンスとして、複数のスレッドから利用することが可能です。LEDRing クラスの点灯方式は２つあります。ひとつは内部制御点灯です。内部制御点灯とは、Arduino スケッチに組み込まれたパターンでのアニメーションを行う点灯方式のことです。フレームは固定となり、アニメーションパターンも限られますが、簡単に点灯させることが可能で、パターンが内部に組み込まれていることから、libtumbler の制御を離れた後にもアニメーションを継続することが可能です。

もうひとつは外部制御点灯です。外部制御点灯とは、libtumbler から通信によるリアルタイム制御でアニメーションを行う点灯方式のことです。フレームや動き方が変化するような複雑なアニメーションパターンを実行させることができますが、libtumbler の制御を離れた後に、当該パターンを維持することはできません。

##### インスタンスの取得

`LEDRing& ring = LEDRing::getInsntance()` として LED リングのインスタンスを取得します。引数はありません。

##### reset()

``````````.cpp
int LEDRing::reset(bool async)
``````````

LED リングをリセットし全消灯します。第一引数ではリセット命令の終了を待たない（非同期的に実行する）かどうかを指定します。通常は待つ必要がないため、`true` を指定することができます。

##### motion()

``````````.cpp
int LEDRing::motion(bool async, uint8_t animationPattern, const Frame& frame);
``````````

内部制御点灯を行います。第一引数では、内部制御点灯命令の完了を待たない（非同期的に実行する）かどうかを指定します。通常は待つ必要はないため、`true` を指定することができます。第二引数は、内部に組み込まれたアニメーションパターンを指定します。0 の場合、アニメーションしません（停止）、1 の場合、時計回りに回転します。2 の場合、反時計回りに回転します。第三引数では、アニメーションに用いるフレームを１つ指定します。内部制御点灯ではアニメーション中にフレームを変更することはできません。この関数が呼ばれた直後 LED リングは一度リセットされます。

アニメーションパターンは内部に組み込まれているため、この関数が呼ばれた後は、libtumbler の制御を離れても、同じアニメーションパターンでの点灯が継続されます。

##### addFrame() / setFrames() / clearFrames()

``````````.cpp
void LEDRing::addFrame(const Frame& frame);
void LEDRing::setFrames(const std::vector<Frame>& frames);
void LEDRing::clearFrames();
``````````

外部制御点灯では、追加した複数フレームを、指定した FPS で順に点灯させるという処理を行います。この関数では、LEDRing クラスに対して、フレームを追加または複数フレームをまとめてセットし、準備します。

##### clearFrames()

``````````.cpp
void LEDRing::clearFrames();
``````````

登録されたフレームを削除します。フレームを削除するだけでは LED リングは消灯しません。LED リングを消灯したいときは、`reset()` 関数を用いるか、明示的に消灯された LED をセットしたフレームを `show()` してください。

##### setFPS()

``````````.cpp
void LEDRing::setFPS(int fps);
``````````

外部制御点灯では、追加した複数フレームを、指定した FPS で順に点灯させるという処理を行います。この関数では、LEDRing クラスに登録された複数フレームを何FPSで表示するかを指定します。FPS（Frame Per Seconds）は、1 秒間に表示されるフレーム数を表します。10 FPS の場合、1 秒間に 10 フレームが表示されることになります。ただし、セットされた FPS は要求 FPS であり、大きすぎる FPS は再現されません。FPS のデフォルト値は 1 です。この関数は、内部制御点灯には影響を与えません。

##### show()

``````````.cpp
void LEDRing::show(bool async);
``````````

addFrame() / setFrames(), setFPS() が呼ばれた後に、実際に外部制御点灯を実行します。第一引数では、外部制御点灯命令の完了を待たない（非同期的に実行する）かどうかを指定します。この関数は、登録されたフレームをすべて表示した後に終了します。すなわち、同期的に呼ばれた `show()` 関数は、登録されたすべてのフレームを表示し終わるまでブロックされます。再生終了後、LED リングは、登録されたフレーム群の最後のフレームが固定表示され続けます。この固定表示状態は、LED リング内部で処理されているため、libtumbler のプロセスの存在に関わらず、常に表示され続けることに留意してください。

典型的な利用事例として、発話開始イベントの発生時に、登録されたアニメーションフレームを非同期で再生開始し、発話終了イベントの発生時に、LED リングをクリアする（もしくは何らかのアニメーションパターンを内部制御点灯で非同期で再生開始する）等があります。この利用例については、`examples/ledring2.cpp` を参考にすることができます。

### タッチボタン制御

#### Buttons クラス

Buttons クラスは、Tumbler の上面パネルに設置された４つのタッチボタン群を表すクラスです。シングルトン・インスタンスとして、複数のスレッドから利用することが可能です。Buttons クラスは、デフォルトではマルチタッチを許可していますが、設定によりシングルタッチのみに強制することができます。ボタン間の距離が近いため、誤って隣のボタンに触れてしまう場合があり、このような場合の誤動作を防ぐために、シングルタッチの強制は役に立つ場合があります。ボタンへのタッチが検出された場合、ユーザー定義コールバック関数が呼ばれます。

サンプルプログラムは `/examples` 以下にあります。

##### インスタンスの取得

``````````.cpp
Buttons& button = Buttons::getInsntance(ButtonStateCallback func, void* userdata); // (1)
Buttons& button = Buttons::getInsntance(ButtonStateCallback func, const ButtonDetectionConfig &config, void* userdata); // (2)
``````````

以上のように Button クラスのインスタンスを取得することができます。第一引数には、ボタンがタッチされたときに呼ばれるコールバック関数を指定します。(2) のオーバーロード関数では、第二引数にボタン検出の設定を与えます。第三引数には、コールバック関数に渡される任意のデータを指定することができます。

##### start()

``````````.cpp
void Buttons::start()
``````````

タッチボタンの検出を開始します。

##### stop()

``````````.cpp
void Buttons::stop()
``````````

タッチボタンの検出を終了します。

#### ButtonState 型

``````````.cpp
enum class DLL_PUBLIC ButtonState
{
	none_,    //!< 何も検知されていない状態
	pushed_,  //!< 指の接触が検知された状態
	released_,//!< 接触検知状態から、指が離された状態（pushed_ ステートからの変化として 1 回のみ呼ばれ、以降は none_ ステートになる）
};
``````````

`ButtonState` 型は、タッチボタンの検出状態を表す列挙型です。それぞれの値の意味は上記の通りとなりますが、留意点として、`ButtonState::released_` ステートは、`ButtonState::pushed_` ステートからの変化として、指が離されたときに 1 回のみ出現することに留意してください。すなわちステートは、`... -> none_ -> none_ -> pushed_ -> pushed -> ... -> pushed_ -> released_ -> none_ -> none -> ...` のように変化します。

#### ButtonInfo クラス

``````````.cpp
class DLL_PUBLIC ButtonInfo
{
public:
	std::vector<int> baselines_;  //!< 各タッチボタンのベースライン補正値（非接触状態の測定値）
	std::vector<int> corrValues_; //!< ベースライン補正値を減算した各タッチボタンの補正済計測値
};
``````````

`ButtonInfo` クラスは、接触状態の測定結果を保有するデータクラスです。通常は利用することはありません。

#### ButtonDetectionConfig クラス


``````````.cpp
class DLL_PUBLIC ButtonDetectionConfig
{
public:
	bool multiTouchDetectionEnabled_ = true; //!< マルチタッチを有効にする（マルチタッチ無効の場合は、先に押されたボタンのみ有効。完全同時に押された場合は、より強く押された方のみ有効となる）
	bool manualThreshold_ = false; //!< 補正済計測値からの増分閾値を以下に指定する指定値にする
	int manualThresholdValues_[4]; //!< 増分閾値の指定
};
``````````

タッチボタンの検出設定を行う設定データクラスです。`multiTouchDetectionEnabled_` によりマルチタッチの有効／無効を設定することができます。デフォルトでは、上記の通り、マルチタッチが有効になっています。`manualThreshold_` は、タッチセンサーの検出閾値をユーザー指定値にすることができる設定項目であり、ユーザー指定値については `manualThresholdValues_` に指定を行いますが、通常は利用することはありません。特段の事情により、タッチセンサーの感度を強制的に下げる／上げる場合には、30 〜 40 を中心として上下に設定を調整することができます。 値が小さい方がより高感度になり、値が大きい方が、より低感度になります。

#### ButtonStateCallback コールバック関数

``````````.cpp
void (*)(std::vector<ButtonState>, ButtonInfo, void*);
``````````

タッチボタンへのタッチが検出された際に呼び出されるユーザー定義コールバック関数です。第一引数に `ButtonState` 型の変数によりボタンのタッチ状態が返されます。第二引数は `ButtonInfo` 型の変数により、タッチ検出の内部状態が返されます。これは通常は利用しません。第三引数には、ユーザー指定の任意のデータが返されます。

コールバック関数は、指の接触が検知されている状態（`ButtonState::pushed_`）のとき、及び、接触検知状態から指が離されたとき（`ButtonState::released_`）の場合のみ呼ばれます。言い換えると、ステートが `ButtonState::none_` のときにはコールバック関数は呼ばれないことに留意してください。


